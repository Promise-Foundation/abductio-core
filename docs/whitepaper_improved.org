#+TITLE: ABDUCTIO v2
#+SUBTITLE: Symmetric Evidence Updates, Anti-Inflation Aggregation, and VOI-Lite Scheduling
#+AUTHOR: David Joseph (adaptable)
#+DATE: December 19, 2025
#+OPTIONS: toc:2 num:t
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage{amsmath, amssymb}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{tabularx}

* Abstract
ABDUCTIO v2 is a lightweight, domain-agnostic methodology for evaluating a mutually exclusive, collectively exhaustive (MECE) set of hypotheses under strict resource constraints. It eliminates focal privilege by enforcing permutation invariance: the output assigned to any hypothesis is independent of ordering or seed choice.

This revision strengthens inferential quality without adding Bayesian machinery: evidence updates are symmetric (up or down), aggregation avoids decomposition-driven inflation, and scheduling prioritizes uncertainty rather than "most likely." The result remains implementation-ready, credit-bounded, and fully auditable.

* 1. Motivation and Problem
Many controversial evaluations fail for a structural reason:

- Hypothesis \(H^*\) (often "far-fetched") is decomposed into multiple subclaims.
- Rival hypotheses \(R_i\) remain broad or underspecified.
- Evidence undermining one subclaim of \(H^*\) shifts weight to rivals.
- Rivals gain weight not because they are supported, but because they were not required to articulate necessary commitments.

This is not merely a cognitive bias--it is a systems design failure. If the procedure taxes some hypotheses with specificity and not others, it bakes in unfairness.

ABDUCTIO addresses this by requiring:
1) every hypothesis to be defined as a stand-alone mechanism, and
2) every hypothesis to be evaluated under the same obligation template and the same credit schedule, independent of ordering.

* 1.1 Scope vs Hypotheses: A Functional Distinction
ABDUCTIO evaluates a MECE set of *hypotheses* about a *scope*. The scope is the
question, phenomenon, or case under evaluation - it defines what the hypothesis set
is partitioning. This is a *functional* distinction, not an ontological one.

Examples:

- **Scope**: "Germany's GDP trajectory in 2026"
  **Hypotheses**: {grow, flat, shrink, other}

- **Scope**: "Why did the Ariel School incident occur?"
  **Hypotheses**: {hoax, misidentified_aircraft, shared_hallucination,
                   unknown_phenomenon, other}

The same statement can play different roles depending on the level of analysis.
"The economy will grow" is:
- A *hypothesis* when evaluating "What will happen to GDP?"
- A *scope* when evaluating "Why would the economy grow?"

Without an explicit scope, MECE accounting becomes ambiguous: H_other means
"other explanation of what?" The scope answers this question and makes audit
trails readable.

* 2. Core Requirement: Permutation Invariance
** 2.1 Informal statement
Given the same hypothesis set, the same evidence, and the same credit budget, the final \((p,k)\) assigned to any hypothesis must not depend on:
- which hypothesis was chosen as "focal,"
- the order hypotheses are listed,
- the order evaluation steps are printed.

** 2.2 Formal statement
Let \(H=\{h_1,\dots,h_n\}\) be a MECE set in closed-world mode, or \(H=\{h_1,\dots,h_n,h_{\text{other}}\}\) in open-world mode. Let an engine \(F\) map:
\[
F(H,E,B,\theta) \mapsto \{(p(h_i),k(h_i))\}_{i=1}^n \cup (p(h_{\text{other}}),k(h_{\text{other}}))
\]
where \(E\) is evidence, \(B\) a credit budget, and \(\theta\) configuration parameters.

Permutation invariance requires that for any permutation \(\pi\) of the *named* hypotheses,
\[
F(H,E,B,\theta) = F(\pi(H),E,B,\theta)
\]
up to the same renaming/reordering of outputs.

** 2.3 Design implications
Permutation invariance forces three conditions:

1) *Semantic independence*: each hypothesis must be meaningful without reference to a "seed."
2) *Procedural symmetry*: credit allocation and stopping rules must not privilege any hypothesis.
3) *Determinism*: tie-breaking must not depend on presentation order.

ABDUCTIO v2 implements all three.

* 3. Design Principles
** P1. Stand-alone hypotheses
Each named hypothesis must be describable without mentioning any other hypothesis. Prohibited: "NOT H1," "some mundane explanation," "any other cause," or umbrella OR-bundles as roots.

** P2. MECE + explicit Other (open-world mode)
The set of named hypotheses is intended to be mutually exclusive (ME) and collectively exhaustive (CE). In open-world mode, collective exhaustiveness is implemented by including:
- \(H_{\text{other}}\): "Unknown/unmodeled explanation."

** P3. No-free-probability
Listing more subcases must not increase a hypothesis's probability. Decomposition clarifies structure; it does not create credence.

** P4. Same burdens for all
Each hypothesis is evaluated through a fixed *obligation template* (Section 6). This prevents one hypothesis from being saddled with "cosmic feasibility" while rivals face only local plausibility checks.

** P5. Credit-bounded termination
Only two operations exist (Evaluate, Decompose), each costing 1 credit. The process halts by budget or by meeting confidence thresholds.

** P6. Fully auditable
Every update must be reproducible from logged arithmetic and rubric scoring. No "implicit" ledger shifts are allowed.

* 4. Data Model
** 4.1 Hypothesis roots and nodes
A hypothesis is represented as a root node with an obligation template and optional internal decomposition trees.

#+begin_src python
from dataclasses import dataclass, field
from typing import Optional, Literal, Dict, List, Tuple

Role = Literal["NEC", "EVID"]
DecompType = Literal["AND", "OR"]
OrMode = Literal["EXCLUSIVE", "INCLUSIVE"]
ScopeMode = Literal["CLOSED_WORLD", "OPEN_WORLD"]

@dataclass
class EvaluationSession:
    """
    A scoped hypothesis evaluation run.

    The scope defines what the MECE hypothesis set is about.
    It's not itself a hypothesis - it's the frame for the partition.
    """
    scope: str                              # "Germany's 2026 GDP trajectory"
    hypothesis_set: HypothesisSet           # The MECE partition being evaluated
    config: SessionConfig                   # tau, epsilon_prio, beta, W, delta, mode, gamma0
    credits_budget: int                     # Total operations allowed

@dataclass
class Node:
    id: str
    statement: str

    # Local scores for this node (not ledger probability)
    p: float = 0.5          # neutral assessment for NEC/EVID
    k: float = 0.15

    # Audit
    k_rubric: Optional[Dict[str, int]] = None  # {"A":0..2,"B":0..2,"C":0..2,"D":0..2}
    factors: List[str] = field(default_factory=list)
    mind_change: Optional[str] = None
    evidence_refs: List[str] = field(default_factory=list)

    # Decomposition
    role: Optional[Role] = None
    children: Dict[str, "Node"] = field(default_factory=dict)
    decomp_type: Optional[DecompType] = None
    or_mode: Optional[OrMode] = None

    # AND coupling for NEC children within a slot
    coupling: Optional[float] = None  # one of {0.20, 0.50, 0.80, 0.95}

    # Accounting
    credits_spent: int = 0
    status: Optional[str] = None      # "SCOPED", "UNSCOPED"

@dataclass
class RootHypothesis:
    id: str
    statement: str
    exclusion_clause: str  # one line: what makes this not any other root

    # Ledger probability (MECE bookkeeping)
    p_ledger: float
    k_root: float = 0.15

# Obligation slots (fixed template; Section 6)
    obligations: Dict[str, Node] = field(default_factory=dict)

    # Audit
    credits_spent: int = 0

@dataclass
class HypothesisSet:
    roots: Dict[str, RootHypothesis]  # includes "H_other" only in open-world mode
#+end_src

** 4.2 Ledger invariants
Closed-world mode:
- \(p_{\text{ledger}}(h) \in [0,1]\)
- \(\sum_{i=1}^n p_{\text{ledger}}(H_i) = 1\)

Open-world mode:
- named roots + \(H_{\text{other}}\) with \(\sum p_{\text{ledger}} = 1\)
- \(H_{\text{other}}\) is a first-class hypothesis with its own ledger mass

* 5. Cost Model
Only two operations exist.

- =DECOMPOSE(target)= : 1 credit
- =EVALUATE(target)= : 1 credit

Everything else (aggregation, ledger enforcement, scheduling) is "free" but must be logged.

* 6. Obligation Template (Permutation-Invariance Backbone)
Every named root hypothesis must be evaluated through the same template of obligation slots. This guarantees that each hypothesis faces comparable explanatory burdens.

** 6.1 Required slots (default v2)
Each root \(H_i\) must define four slots:

1) *Feasibility (general)* [NEC]
   - The mechanism is possible in principle.
2) *Availability (context)* [NEC]
   - The mechanism is present/available in the specific time/place/context.
3) *Fit to key features* [NEC]
   - The mechanism explains the core reported observations better than at least one competitor.
4) *Defeater resistance* [NEC]
   - The strongest competitor-specific defeater does not apply.

These are expressed as NEC nodes. Additional EVID nodes are allowed but may not be used to inflate probability.

** 6.2 Template customization
Implementations may add slots, but must:
- apply the same slots to all named roots, and
- keep total slots small (4-7 recommended).

** 6.3 Why this matters
Without a template, decomposition can be weaponized: one hypothesis can be loaded with "universal feasibility" while rivals get only vague local stories. Template parity removes this asymmetry.

* 7. Semantics of p within trees ("No-free-probability")
ABDUCTIO v2 distinguishes *ledger probability* from *internal node p*:

- \(p_{\text{ledger}}(H_i)\): MECE bookkeeping probability over roots.
- \(p(\text{NEC/EVID node})\): assessment score used to compute a bounded weight of evidence.

** 7.1 Neutral defaults
Unassessed nodes do not move the ledger:
- NEC/EVID nodes initialize at \(p=0.5\) (neutral) with low \(k=0.15\).
- Unassessed slots contribute \(w=0\) to ledger updates (Section 11).

** 7.2 Consequence
Decomposition cannot lower or raise a hypothesis merely by adding structure. Only evaluated requirements can move the ledger, and moves are symmetric (up or down). DECOMPOSE never changes ledger beliefs; it creates nodes with \(w=0\) until EVALUATE occurs.

* 8. Confidence k: Rubric and Mapping
Confidence \(k\) is the stability/robustness of a credence estimate under reasonable re-checking.

** 8.1 Rubric (0-2 each)
A: Evidence Traceability
B: Cross-Validation
C: Sensitivity to Assumptions
D: Adversarial Resilience

Total \(T=A+B+C+D\) maps to:

- 0-1 -> 0.15
- 2-3 -> 0.35
- 4-5 -> 0.55
- 6-7 -> 0.75
- 8 -> 0.90

Guardrail: if any check = 0, cap \(k \le 0.55\).

** 8.2 Root confidence
Root confidence \(k_{\text{root}}\) is defined deterministically as the minimum \(k\) over required NEC slots (conservative). If UNSCOPED, cap:
\[
k_{\text{root}} \le k_{\max}^{\text{UNSCOPED}}.
\]
Log the chosen rule and caps.

* 9. Decomposition Rules
** 9.1 Root scoping is mandatory
All named roots must be decomposed into the obligation template before any root can be accepted as "well-scrutinized."

** 9.2 Additional decomposition within slots (optional)
Each slot node may be decomposed further (2-5 children) when its confidence is below threshold and credits remain.

** 9.3 Coupling for AND nodes (within a slot)
When decomposing a slot into an AND of NEC children, choose coupling \(c \in \{0.20,0.50,0.80,0.95\}\) deterministically from overlap scores (Section 9.5).

Soft-AND for assessed children:
\[
p_{\text{AND}} = c \cdot p_{\min} + (1-c)\cdot p_{\prod}
\]
where \(p_{\min}\) and \(p_{\prod}\) are computed over assessed NEC children (unassessed treated as 0.5).

** 9.4 OR aggregation (anti-inflationary)
Default OR aggregator is max:
\[
p_{\text{OR}}=\max_j p_j
\]
Interpretation: a parent is supported at least as well as its strongest child.

Optional discounted noisy-OR (requires explicit overlap discount \(d\in(0,1]\)):
\[
p_{\text{OR}} = 1 - \prod_j (1-p_j)^{d}
\]
Higher overlap \(\Rightarrow\) smaller \(d\) \(\Rightarrow\) less inflation.

** 9.5 Overlap checklist to choose coupling
Score overlap on three rubric items (0-2 each):
- Evidence overlap
- Mechanism overlap
- Failure-mode overlap

Let \(T\in\{0,\dots,6\}\) be the sum. Map deterministically to \(c\):
- \(T \in \{0,1\}\Rightarrow c=0.20\)
- \(T \in \{2,3\}\Rightarrow c=0.50\)
- \(T \in \{4,5\}\Rightarrow c=0.80\)
- \(T = 6\Rightarrow c=0.95\)

All scores and the resulting \(c\) are logged.

If noisy-OR is enabled, use the same \(T\) to choose overlap discount \(d\):
\[
d=\begin{cases}
1.00,& T\in\{0,1\}\\
0.75,& T\in\{2,3\}\\
0.50,& T\in\{4,5\}\\
0.35,& T=6
\end{cases}
\]
Log \(T\) and the resulting \(d\).

** 9.6 Coupling scope clarification
Coupling applies only to AND children *within a slot*. Across the template slots, ABDUCTIO v2 uses evidence weights (Section 11) rather than multiplying slot \(p\) values.

* 10. Anti-Vagueness (UNSCOPED rule)
A mechanism-like hypothesis must be able to state concrete necessary commitments.

** Rule (root level)
If a named root cannot instantiate the obligation template with meaningful NEC statements, it is marked UNSCOPED and:
- cap \(k_{\text{root}} \le 0.40\),
- it remains in the evaluation schedule until it becomes SCOPED or credits exhaust.

** Rule (slot level)
If a slot cannot be decomposed into at least 1 meaningful NEC statement, cap that slot's \(k \le 0.40\).

This prevents "winning by labels."

* 11. Symmetric Evidence Updates (Log-Space)
Ledger updates are symmetric: evidence can increase or decrease a hypothesis.

** 11.1 Log-space update with bounded per-credit effect
Maintain ledger probabilities \(p(h)\) over MECE roots. Each evaluated slot yields a signed, bounded weight of evidence \(w_{h,s}\in[-W, W]\).

Unnormalized update:
\[
\log \tilde p(h) = \log p(h) + \sum_{s\in \mathcal{S}_{\text{eval}}(h)} w_{h,s}
\]
Normalize across named roots (open-world handling in Section 12):
\[
p'(h)=\frac{\tilde p(h)}{\sum_{g\in H}\tilde p(g)}
\]

** 11.2 Deterministic mapping from \((p_{h,s}, k_{h,s})\) to \(w_{h,s}\)
Evaluators return:
- \(p_{h,s}\in(0,1)\) (slot assessment centered at neutral \(0.5\))
- \(k_{h,s}\in[0,1]\) (confidence)

Clamp to avoid infinities:
\[
p_{h,s}^{\ast}=\mathrm{clip}(p_{h,s},\eta,1-\eta),\quad \eta\ll 1
\]

Map to weight:
\[
w_{h,s}=\mathrm{clip}\!\left(\beta\, k_{h,s}\cdot \log\frac{p_{h,s}^{\ast}}{1-p_{h,s}^{\ast}},\; -W,\; W\right)
\]
where \(\beta>0\) is a global scaling parameter, \(W>0\) is a per-credit cap, and \(\eta\) is a logit safety clamp (e.g., \(10^{-6}\)).
All clamps and clips must be logged.

** 11.3 Neutral defaults are zero evidence
- Unassessed NEC slots contribute no update: \(w=0\) by default.
- If a displayed slot score is needed, use \(p_{h,s}=0.5\) with low \(k\).

This keeps "no-free-probability" while enabling symmetric moves when evidence exists.

* 12. Open-World vs Closed-World Ledger Handling
** 12.1 Closed-world mode
Outcomes are exhaustive by construction. No absorber hypothesis is used.
\[
\sum_{h\in H} p(h)=1,\quad H_{\text{other}} \text{ omitted}
\]

** 12.2 Open-world mode
Include \(H_{\text{other}}\) as a true hypothesis. Maintain MECE bookkeeping over \(H\cup\{H_{\text{other}}\}\).

** 12.3 Adaptive \(\gamma\) (open-world only)
Initialize \(p(H_{\text{other}})=\gamma_0\) small (e.g., 0.01-0.05).
Allow \(\gamma\) to increase or decrease only via auditable triggers, such as:
- persistent UNSCOPED status after \(N\) scoping attempts,
- repeated contradictions / residual mismatch flags,
- evaluator flags "missing hypothesis class."

All adjustments are logged as explicit operations (or as deterministic "free" bookkeeping steps with full arithmetic disclosure). In closed-world mode, do not allow \(H_{\text{other}}\) to absorb arithmetic residuals.

* 13. Scheduling: VOI-Lite, Deterministic
Frontier-by-probability is replaced by a deterministic priority score that favors uncertainty and low confidence.

** 13.1 Priority score
Define per-hypothesis priority:
\[
\mathrm{priority}(h)=p(h)\bigl(1-p(h)\bigr)\cdot (1-k(h))\cdot I(h)
\]
where \(I(h)\ge 0\) is a scope-provided importance weight (default \(1\)).

** 13.2 Frontier definition by priority band
Let \(h^\star=\arg\max_h \mathrm{priority}(h)\).
Frontier:
\[
F=\left\{h:\mathrm{priority}(h)\ge \mathrm{priority}(h^\star)-\varepsilon_{\text{prio}}\right\}
\]
Ordering within frontier remains canonical by hash(statement), preserving permutation invariance.

** 13.3 Deterministic operation choice per hypothesis
For a root \(H_i\) in frontier, choose:

1) If \(H_i\) is UNSCOPED: DECOMPOSE (attempt to scope template or slot).
2) Else if any required slot is uninstantiated: DECOMPOSE to create missing slot node(s).
3) Else pick the slot \(s\) with lowest \(k\) (tie-break canonically by node ID):
   - If slot can be decomposed and \(k < \tau\): DECOMPOSE(slot)
   - Else: EVALUATE(slot) or EVALUATE(slot's most critical child)

** 13.4 Tie-breaking (mandatory)
All ties are broken by canonical ID derived from the statement text (hash), never by input ordering.

* 14. Stopping Conditions
Stop when any holds:

A) credits exhausted.
B) For all hypotheses in the current frontier:
   - root is SCOPED,
   - all template NEC slots have \(k \ge \tau\) (or credit exhaustion prevents further improvement).
C) No legal next operation exists (e.g., maximum decomposition depth reached and no evaluable nodes remain).
D) Early stopping: for all frontier hypotheses,
   \[
   \max_{h\in F}\; (W\cdot \bar k_h) \le \delta
   \]
   where \(\bar k_h\) is the confidence of the next eligible node.

* 15. Evaluator and Decomposer Interfaces (Implementation Contracts)
** 15.1 Evaluator contract (human or agent)
=evaluate(node, evidence)= returns:
- p in (0,1) centered at 0.5 (slot assessment)
- rubric A-D scores and derived k
- 1-3 short factors
- mind_change sentence
- explicit assumption list if evidence is weak, each tagged with fragility (low/med/high)
- evidence_refs used (may be empty)

Constraints:
- If no evidence_refs: enforce conservative p movement (implementation default: |delta p| <= 0.05 from prior node.p)
- Evaluator must not reference "seed" or "focal" status.

** 15.2 Decomposer contract
=decompose(node)= returns:
- 2-5 children nodes, each labeled NEC or EVID
- decomp_type AND/OR; for OR, mode EXCLUSIVE/INCLUSIVE
- for AND with NEC, coupling bucket c (via overlap checklist in Section 9.5)

Constraints:
- For root hypotheses, decomposer must instantiate the obligation template.
- If cannot, mark UNSCOPED.

* 16. Inference vs Decision (Two-Layer Architecture)
ABDUCTIO v2 separates inference from decision:

- *Inference layer*: maintains \(\{p(h), k(h)\}\) and updates via \(\{w_{h,s}\}\).
- *Decision layer (plug-in)*: uses \(\{p(h), k(h)\}\) plus a domain utility function \(U\) to choose actions.

This preserves domain agnosticism and avoids embedding domain-specific EV calculations into the core.

** 16.1 Minimal decision plug-in contract
Decision plug-in (conceptual) inputs and outputs:
- Inputs: current ledger \(\{p(h),k(h)\}\), scope metadata, utility \(U\), constraints
- Output: action(s) (e.g., investigate node, accept hypothesis, place bet, abstain), with logged rationale

* 17. Calibration Harness (Optional, Domain-Agnostic)
** 17.1 Post-hoc calibration by \(k\)-bucket
When outcomes resolve, compute calibration diagnostics (e.g., Brier score, reliability curves) stratified by \(k\) buckets.

** 17.2 Adjust only global scalars
Tune (walk-forward):
- \(\beta\) (evidence weight scale),
- \(W\) (per-credit cap),
- rubric-to-\(k\) mapping thresholds,
- \(\varepsilon_{\text{prio}}, \delta\) (scheduling/stop parameters)

Objective: reduce systematic miscalibration without requiring domain-specific features.

* 18. Algorithm (Updated Pseudocode)
#+begin_src text
inputs:
  scope text
  roots: List[RootSpec]
  credits B
  tau, epsilon_prio, beta, W, eta, delta
  mode (closed-world or open-world), gamma0

initialize:
  for each root in roots:
    canonical_id[root] = hash(root.statement)
  build named roots H1..Hn from roots
  if open-world:
    add H_other with statement "Other" and exclusion "Not any named root"
    set p_other = gamma0, p_i = (1-gamma0)/n
  else:
    set uniform priors: p_i = 1/n
  set all k = 0.15
  set all status = UNSCOPED initially

for cycle = 1.. while credits > 0:
  for each root, compute priority = p(1-p)(1-k)I
  leader = argmax priority (tie-break by canonical_id)
  frontier F = {Hi : priority(Hi) >= priority(leader) - epsilon_prio}

  order frontier by canonical_id
  for Hi in F:
    if credits == 0: break

    choose operation deterministically:
      if Hi is UNSCOPED or missing template slots:
         DECOMPOSE(Hi)
      else:
         pick slot s with lowest k (tie-break by canonical_id)
         if can_decompose(s) and k(s) < tau:
             DECOMPOSE(s)
         else:
             EVALUATE(s)

    spend 1 credit
    update credits_spent on Hi and node
    recompute slot p_s and k_s via aggregation if needed
    clamp p_s to [eta, 1-eta] and compute w_{h,s} from p_s and k_s
    update log p(h) with sum of w_{h,s}
    normalize ledger over named roots
    if open-world: adjust H_other via gamma rules
    log clamps, clips, and every arithmetic step and invariant check

stop when stopping conditions met
output full audit trace
#+end_src

* 19. Practical Defaults
- tau = 0.70
- epsilon_prio = 0.05
- beta = 1.0
- W = 1.0
- eta = 1e-6
- delta = 0.05
- mode = closed-world (most outcomes)
- gamma0 = 0.02 (open-world only)
- k_max_UNSCOPED = 0.40
- max_children = 5
- coupling_default = 0.80
- conservative delta p when no evidence: |delta p| <= 0.05 per evaluation

* 20. Configuration Parameters (v2)
| Parameter | Meaning | Typical Default |
|----------+---------+-----------------|
| \(\beta\) | evidence weight scale | 1.0 |
| \(W\) | per-credit weight cap | 1.0 |
| \(\eta\) | logit clamp | 1e-6 |
| mode | closed-world / open-world | closed-world |
| \(\gamma_0\) | initial other mass (open-world only) | 0.02 |
| \(\varepsilon_{\text{prio}}\) | frontier band on priority | 0.05 |
| \(\delta\) | early-stop movement threshold | 0.05 |
| \(k_{\max}^{\text{UNSCOPED}}\) | cap for unscoped roots | 0.40 |

* 21. Invariants Preserved
- *Permutation invariance*: canonical_id ordering + deterministic tie-breaks
- *Credit-boundedness*: only DECOMPOSE/EVALUATE spend credits; belief impact only on EVALUATE
- *Auditability*: every \(p\), \(k\), \(w\), clamp/clip, normalization, and scheduling decision logged
- *Domain agnosticism*: core uses bounded evidence weights; decision policy is a plug-in

* 22. Why ABDUCTIO v2 is Permutation-Invariant
ABDUCTIO v2 achieves permutation invariance by construction:

1) No focal injection: frontier depends only on ledger state.
2) Canonical ordering: iteration order is defined by hash(statement), not by input list order.
3) Round-robin slicing: each frontier hypothesis receives equal opportunity per cycle.
4) No-free-probability semantics: decomposition cannot change ledger p; OR cannot inflate.
5) Template parity: each hypothesis is evaluated under the same obligation slots.
6) Deterministic tie-breaks everywhere.

Given identical inputs, the engine performs the same operations in the same canonical order and produces identical outputs, independent of the seed.

* 23. Limitations and Extensions
** Limitations
- This is not full Bayesian inference; it is a structured, auditable scoring-and-budgeting framework.
- Results depend on evaluator discipline and evidence quality.
- MECE is approximated; open-world mode adds H_other as a guardrail, not a full causal model.

** Extensions
- Multi-assessor panels with aggregation rules for p and k.
- Evidence objects with explicit likelihood impacts.
- Specialized decomposers per domain (medicine, security, historical events).

*** Recursive MECE Sets (Future)
Any obligation node can spawn a local MECE hypothesis set when uncertainty
is better modeled as competing scenarios rather than a single requirement.

Example: Within "Germany will grow" -> "External environment" slot, instead of
a vague NEC statement, spawn:
- **Local scope**: "External economic environment for Germany in 2026"
- **Local hypotheses**: {improves, stable, deteriorates, other}

Each local set has its own:
- Ledger with H_other (open-world mode only)
- Template obligations (or simplified template)
- Credit allocation with depth limits

The parent node's satisfaction score becomes:
\[
p(\text{parent}) = \sum_{s \in \text{satisfying scenarios}} p_{\text{local\_ledger}}(s)
\]

This enables:
- Modeling of nested uncertainties matching expert reasoning patterns
- Explicit representation of assumption dependencies
- Protection against hidden vagueness at arbitrary depth

Design requirements:
- Deterministic roll-up from local ledger to parent p
- Same permutation invariance at every level
- Depth limits and credit allocation rules to bound complexity
- Clear audit trail showing which local scenarios drive parent scores

* Appendix A: Minimal "Well-Defined Hypothesis" Checklist
A root hypothesis must include:
- A mechanism statement (stand-alone).
- An exclusion clause distinguishing it from other roots.
- A template instantiation with NEC slots:
  feasibility, availability, fit, defeater resistance.

If it cannot, mark UNSCOPED and cap k.

* Appendix B: Canonical ID and Permutation Invariance
ABDUCTIO uses content-based canonical IDs to break ties deterministically without
depending on input order.

For any hypothesis statement:
\[
\text{canonical\_id}(h) = \text{SHA256}(\text{normalize}(h.\text{statement}))
\]

Where normalization:
1. Converts to lowercase
2. Collapses whitespace (multiple spaces/tabs/newlines -> single space)
3. Strips leading/trailing whitespace

This ensures:
- Identical statements produce identical IDs regardless of formatting
- IDs are stable across sessions
- Frontier ordering is deterministic: when multiple hypotheses tie, they're ordered
  by canonical_id, not by the order they were provided

Example:
#+begin_src python
statement1 = "Economy will   grow\n  next year"
statement2 = "economy will grow next year"
# normalize(statement1) == normalize(statement2)
# canonical_id(statement1) == canonical_id(statement2)
#+end_src

* Appendix C: Coupling Buckets and Noisy-OR Discount
Score overlap on three rubric items (0-2 each):
- Evidence overlap
- Mechanism overlap
- Failure-mode overlap

Map sum \(T\) to coupling:
- 0-1 -> 0.20
- 2-3 -> 0.50
- 4-5 -> 0.80
- 6 -> 0.95

If noisy-OR is enabled, map the same \(T\) to discount \(d\):
\[
d=\begin{cases}
1.00,& T\in\{0,1\}\\
0.75,& T\in\{2,3\}\\
0.50,& T\in\{4,5\}\\
0.35,& T=6
\end{cases}
\]
